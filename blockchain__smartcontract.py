# -*- coding: utf-8 -*-
"""blockchain _smartcontract.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ov9rrW64MaQi1OG2p_ywzYfv-C5_q1cZ

Criação do bloco e blockchain
"""

import hashlib # importa a biblioteca que faz o calculo dos hashes
import json # importa o modulo que manipula arquivos jason
from time import time # importa a funcao time para obter o timestamp

class Bloco:
  def __init__(self, index, dados, hash_anterior=''):
  # inicializar o bloco com os parâmetros fornecidos e os atributos necessarios
    self.index = index # indice do bloco da cadeia
    self.dados = dados # dados armazenados no bloco
    self.hash_anterior = hash_anterior # hash do bloco anterior na cadeia
    self.timestamp = time() # registrar o momento da criacao do bloco
    self.nonce = 0 # Número usado na mineração
    self.hash_atual = self.gerar_hash() # gerar o hash do bloco

  def gerar_hash(self):
    # funcao para gerar o hash SHA-256 do bloco
    conteudo_bloco = json.dumps({
        'index':self.index,
        'dados':self.dados,
        'hash_anterior':self.hash_anterior,
        'timestamp':self.timestamp,
        'nonce': self.nonce
    }, sort_keys=True).encode() # converte os dados do bloco em uma string JSON ordenada
    return hashlib.sha256(conteudo_bloco).hexdigest() #calcula o SHA-256 do conteudo do bloco

  def prova_de_trabalho(self, dificuldade):
    # realiza a prova de trabalho ajustando o nonce até que o hash comece com 'n_dificuldade' zeros
    while self.hash_atual[:dificuldade] != '0' * dificuldade:
      self.nonce += 1 # incrementa o nonce para alterar o hash
      self.hash_atual = self.gerar_hash() # recalcula o hash com novo nonce

class Blockchain:
  def __init__(self):
    # inicializa a blockchain com o bloco genesis e definir a dificuldade da prova de trabalho
    self.cadeia = [self.criar_bloco_genesis()] # lista que armazena os blocos na cadeia
    self.dificuldade = 4 # define o numero de zeros necessarios no hashiamento da prova de trabalho

  def criar_bloco_genesis(self):
    return Bloco(0, "Bloco Genesis", "0")  # Bloco inicial (genesis)

  def obter_ultimo_bloco(self):
    # retorna o ultimo bloco da cadeia
    return self.cadeia[-1]

  def adicionar_bloco(self, novo_bloco):
    # adiciona um novo bloco a cadeia
    novo_bloco.hash_anterior = self.obter_ultimo_bloco().hash_atual # define o hash do bloco anterior
    novo_bloco.prova_de_trabalho(self.dificuldade) # realiza a prova de trabalho para alterar o hash
    self.cadeia.append(novo_bloco) # adiciona o novo bloco à cadeia

  def validar_cadeia(self):
    # valida a integridade da cadeia, validando hashes e encadeamento
    for i in range(1, len(self.cadeia)):
      bloco_atual = self.cadeia[i]
      bloco_anterior = self.cadeia[i-1]


      # verificar se o hash armazenado corresponde ao hash calculado
      if bloco_atual.hash_atual != bloco_atual.gerar_hash():
        return False # retorna false se houver discrepância


      # verificar se o hash do bloco anterior corresponde ao hash armazenado no bloco anterior
      if bloco_atual.hash_anterior != bloco_anterior.gerar_hash():
        return False # retorna false se houver discrepancua
    return True  # retorna true se a cadeia for validada

  def salvar_em_json(self, nome_arquivo='blockchain.json'):
    # salvar a cadeia em um arquivo json
    with open(nome_arquivo, 'w') as arquivo:
      json.dump([bloco.__dict__ for bloco in self.cadeia], arquivo, indent=4)


# funcao para coletar dados de exames medicos
def coletar_dados_exame():
  glicose = float(input('Digite o valor da glicose: '))
  return {
      'glicose': glicose
  } # retorna um dicionario com os dados coletados

"""Instanciar a blockchain"""

blockchain = Blockchain()

"""Adicionar um bloco"""

# coletar os dados de exames do usuario
dados_exame = coletar_dados_exame()

# cria um novo bloco com os dados coletados
novo_bloco = Bloco(blockchain.obter_ultimo_bloco().index + 1, dados_exame)
# define o indice do novo bloco com o indice do ultimo bloco + 1
# associa os dados coletados ao bloco criado

# adiciona o novo bloco a blockchain
blockchain.adicionar_bloco(novo_bloco)


# verificar a integridade da blockchain após a adição do bloco
if blockchain.validar_cadeia():
  blockchain.salvar_em_json()
  print('Blockchain válida!')
else:
  print('Blockchain inválida')



"""Exibir o conteúdo do arquivo JSON"""

def print_json_content(filename):
  # tenta abrir e processar o arquivo json
  try:
    with open(filename, 'r') as file:
      data = json.load(file)
      print(json.dumps(data, indent=4))
  except FileNotFoundError:
    print(f'Erro: Arquivo {filename} não encontrado')
  except json.JSONDecodeError:
    print(f'Erro: Arquivo {filename} não é um JSON válido')

print_json_content('blockchain.json')

class SmartContract:
    def __init__(self, blockchain):
        self.blockchain = blockchain  # associa a blockchain ao contrato inteligente

    def validar_dados(self, dados):
        """
        valida os dados coletados para garantir que estejam dentro dos critérios predefinidos.
        neste exemplo, verificamos se o nível de glicose está em um intervalo saudável.
        """
        glicose = dados.get('glicose')
        if glicose is None:
            return False  # dados inválidos se não houver glicose informada
        if 70 <= glicose <= 140:  # intervalo 'hipotéticamente' saudável de glicose
            return True
        return False

    def adicionar_dados_a_blockchain(self, dados):
        """
        valida os dados e adiciona um bloco à blockchain se os dados forem válidos.
        """
        if self.validar_dados(dados):
            novo_bloco = Bloco(self.blockchain.obter_ultimo_bloco().index + 1, dados)
            self.blockchain.adicionar_bloco(novo_bloco)
            print("Bloco adicionado com sucesso!")
        else:
            print("Dados inválidos. Bloco não adicionado.")

# inicializar a blockchain e o contrato inteligente
blockchain = Blockchain()
contrato = SmartContract(blockchain)

# coletar dados do usuário
dados_exame = coletar_dados_exame()

# usar o contrato para validar e adicionar os dados à blockchain
contrato.adicionar_dados_a_blockchain(dados_exame)

# validar a integridade da blockchain
if blockchain.validar_cadeia():
    blockchain.salvar_em_json()
    print("Blockchain válida e atualizada com sucesso!")
else:
    print("Blockchain inválida!")

# exibir o conteúdo da blockchain
print_json_content('blockchain.json')

